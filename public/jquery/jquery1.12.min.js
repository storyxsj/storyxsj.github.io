
var _CHAN;
var _SURE;
var _Hi = 0;//高K index
var _Li = 0;//低K index
var _HH = 0;//高K高点
var _HL = 0;//高K低点
var _LH = 0;//低K高点
var _LL = 0;//低K低点
var _hasHL = false;//是否己经有高低点 false-否  true-是
var _findHL = false;//true-找高点   false-找低点
var _countH = 0;//确认高点计数器
var _countL = 0;//确认低点计数器
var list1 = [];
var list2 = [];
var list3 = [];
var list4 = [];

function chaninit(){
	_Hi = 0;//高K index
	_Li = 0;//低K index
	_HH = 0;//高K高点
	_HL = 0;//高K低点
	_LH = 0;//低K高点
	_LL = 0;//低K低点
	_hasHL = false;//是否己经有高低点 false-否  true-是
	_findHL = false;//true-找高点   false-找低点
	_countH = 0;//确认高点计数器
	_countL = 0;//确认低点计数器
	list1 = [];
	list2 = [];
	list3 = [];
	list4 = [];
	list5 = [];
}

function chan(date,o,c,l,h){
	chaninit();
	var len = date.length;

	//处理第一条记录
	if(len != 0){
			_HH = h[len-1];
			_LH = h[len-1];
			_HL = l[len-1];
			_LL = l[len-1];
			_Hi = len-1;
			_Li = len-1;	
	}
	//除了第一条之外的其他记录
	var i = len-2;
	
	for(;i>-1&&!_hasHL;i--){//找出第一个高点 或 低点
		buildChan4First(date,o,c,l,h,i);
	}
	
	for(;i>-1;i--){//找其他剩余高低点
		buildChan(date,o,c,l,h,i);
	}
	
	var len_list = list1.length;
	var jsonArrAll = [];
	for(var j=1;j<len_list;j++){
		var jsonArr = [];
		
		var jo1 = {};
		jo1.xAxis = list1[j-1];
		jo1.yAxis = list2[j-1];
		var jo2 = {};
		jo2.xAxis = list1[j];
		jo2.yAxis = list2[j];
		
		jsonArr.push(jo1);
		jsonArr.push(jo2);
		jsonArrAll.push(jsonArr);
		
			
	}
	_CHAN = eval(jsonArrAll);
	
	
	
	var len_list5 = list5.length;
	var jsonArrAll4sure = [];
	for(var m=0;m<len_list5;m++){
		var jo1 = {};
		var ja1 = [];
		ja1[0] = list3[m];
		ja1[1] = list4[m];
		jo1.coord = ja1;
		
		if(list5[m] == 1){
			var jo2 = {};
				var jo3 = {};
				jo3.color = "#74d947";
				jo3.position = "bottom";
			jo2.normal = jo3;	
			jo1.itemStyle = jo2;//eval("{normal: {color: 'rgb(41,60,85)'} }");
		}
       
		
		jsonArrAll4sure.push(jo1);
	}
	_SURE = eval(jsonArrAll4sure);;
	
}


function buildChan4First(dateArr, oArr,cArr, lArr, hArr, i){
	var date = dateArr[i];

	var l = lArr[i];
	var h = hArr[i];

	//更新高低K
	if(parseFloat(h)>parseFloat(_HH)){
		_Hi = i;
		_HH = h;
		_HL = l;
	}
	if(parseFloat(l)<parseFloat(_LL)){
		_Li = i;
		_LH = h;
		_LL = l;
	}
	
	/*
	String s = "2009-01-08";
	if(date.equalsIgnoreCase(s)){
		System.out.println("testing->"+s);
		System.out.println(dateArr[_Hi]);
	}
	*/
	if(parseFloat(l)>parseFloat(_LH)){//First找低点
		_countL++;
		if(_countL == 3){
			
			/*
			if(_Hi-i>2){//连续三个是否存在最大值
				
				_countL--;
				return;
			}
			*/
			
			console.info(date+"First确认低点->"+dateArr[_Li]);
			list1.push(dateArr[_Li]);
			list2.push(lArr[_Li]);
			list3.push(date);
			list4.push(h);
			list5.push(0);
			_findHL = true;
			_hasHL = true;
			
			//更新高低K
			updateHL(hArr,lArr,i,"L");

		}
	}else{
		_countL = 0;
	}
	
	if(parseFloat(h)<parseFloat(_HL)){//First找高点
		_countH++;
		if(_countH == 3){
			if(parseFloat(i)-parseFloat(_Li)>2){
				_countH--;
				return;
			}
			console.info(date+"First确认高点->"+dateArr[_Hi]);
			list1.push(dateArr[_Hi]);
			list2.push(hArr[_Hi]);
			list3.push(date);
			list4.push(h);
			list5.push(1);
			//更新高低K
			updateHL(hArr,lArr,i,"H");
			
			_findHL = false;
			
			_hasHL = true;
		}
	}else{
		_countH = 0;
	}
	
//--未出现高低点逻辑结束------------------------------------------------------
	
}

function buildChan( dateArr, oArr, cArr, lArr, hArr, i){
	var date = dateArr[i];
	//double o = oArr[i];
	//double c = cArr[i];
	var l = lArr[i];
	var h = hArr[i];

	//更新高低点
	if(parseFloat(h)>parseFloat(_HH)){
		_HH = h;
		_HL = l;
		_Hi = i;
	}
	if(parseFloat(l)<parseFloat(_LL)){
		_LH = h;
		_LL = l;
		_Li = i;
	}
	
	//测试用
	var s = "just for debug:2017-03-17";
	if(date == s){
		console.info("testing"+s+","+h+","+_HL);
	}
	
		if(_findHL){//找高点
			
			if(parseFloat(h)<parseFloat(_HL)){
				
				_countH++;
				if(_countH == 3){
					if(i-_Li>2){
						_countH--;
						return;
					}
					console.info(date+"确认高点->"+dateArr[_Hi]);
					_countL = 0;
					list1.push(dateArr[_Hi]);
					list2.push(hArr[_Hi]);
					
					list3.push(date);
					list4.push(h);
					list5.push(1);
					_findHL = false;
					//更新最低值
					updateHL(hArr,lArr,i,"H");
				}
			}else{
				_countH = 0;
			}
		}else{//找低点
			
			if(parseFloat(l)>parseFloat(_LH)){
				//更新高点
				if(parseFloat(h)>parseFloat(_HH)){
					_HH = hArr[i];
					_HL = lArr[i];
					_Hi = i;
				}
				
				_countL++;
				if(_countL == 3){
					if(parseFloat(i)-parseFloat(_Hi)>2){//连续三个是否存在最大值
						_countL--;
						return;
					}
					console.info(date+"确认低点->"+dateArr[_Li]);
					_countH = 0;
					list1.push(dateArr[_Li]);
					list2.push(lArr[_Li]);
					
					list3.push(date);
					list4.push(h);
					list5.push(0);
					_findHL = true;
					updateHL(hArr,lArr,i,"L");
				}
			}else{
				_countL = 0;
			}
		}

		if(date == s){
			console.info("当前 高点:"+dateArr[_Hi]+" 低点："+dateArr[_Li]);
		}

}


function updateHL( hArr, lArr, i, HL){
	if("L"== HL){
		//更新高K
		var maxIdx = getMax(hArr,i);
		_Hi = maxIdx;
		_HH = hArr[maxIdx];
		_HL = lArr[maxIdx];
		//更新低K //找出此时最高点[_Hi]至今[i]的低K
		var k = 0;
		if(parseFloat(_Hi)-parseFloat(i)==2){
			k = getMin(lArr,i);
		}else if(parseFloat(_Hi) - parseFloat(i) == 1){
			if(parseFloat(lArr[i])<parseFloat(lArr[_Hi])){
				k = i;
			}else{
				k = _Hi;
			}
		}else{
			k = i;
		}
		
		_Li = k;
		_LH = hArr[k];
		_LL = lArr[k];
		
	}else{
		//更新低K
		var mimIdx = getMin(lArr,i);
		_Li = mimIdx;
		_LH = hArr[mimIdx];
		_LL = lArr[mimIdx];
		//更新高K //找出此时最高点[_Li]至今[i]的高K
		var k = 0;
		if(parseFloat(_Li)-parseFloat(i)==2){
			k = getMax(hArr,i);
		}else if(parseFloat(_Li)-parseFloat(i) == 1){
			if(parseFloat(hArr[i])>parseFloat(hArr[_Li])){
				k = i;
			}else{
				k = _Li;
			}
		}else{
			k = i;
		}
		_HH = hArr[k];
		_HL = lArr[k];
		_Hi = k;
	}
	
}

function getMax( x, i){
	var a = parseFloat(x[i+2]);
	var b = parseFloat(x[i+1]);
	var c = parseFloat(x[i]);
	var m = 0;
	if(a>b){
		if(a>c){
			m = parseFloat(i)+2;
		}else{
			m = i;
		}
	}else{
		if(b>c){
			m = parseFloat(i)+1;
		}else{
			m = i;
		}
	}
	return m;
}

function  getMin( x, i){
	var a = parseFloat(x[i+2]);
	var b = parseFloat(x[i+1]);
	var c = parseFloat(x[i]);
	var m = 0;
	if(a<b){
		if(a<c){
			m = parseFloat(i)+2;
		}else{
			m = i;
		}
	}else{
		if(b<c){
			m = parseFloat(i)+1;
		}else{
			m = i;
		}
	}
	return m;
}